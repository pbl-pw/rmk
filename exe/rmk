#!/usr/bin/env ruby

require 'optparse'
require 'iniparse'
require "rmk"

options = {}
cache_options = {}
parser = OptionParser.new{ |opts|
	opts.summary_width = 48
	opts.banner = 'Usage: rmk [Options] [targets]'
	opts.separator 'repository options:'
	opts.on '-C', '--directory=dir', 'repository root dir, will change to this dir before other operation, default pwd' do |dir|
		options[:prjroot] = dir
	end

	opts.separator 'directory options(will be cached when seted):'
	opts.on '-O', '--outdir=dir', 'output root dir, can be absolute or relative to repository root, default _Build' do |dir|
		cache_options[:outroot] = dir
	end
	opts.on '-S', '--srcdir=dir', 'source root dir, can be absolute or relative to output root(start with ..), default ..' do |dir|
		cache_options[:srcroot] = dir
	end
	opts.on '--link-outdir=dir', 'symbol link outdir to this dir, default <system temp dir>/<repository name>' do |dir|
		cache_options[:link] = dir
	end
	opts.on '--name=name', "repository name, default repository root dir's name" do |name| cache_options[:name] = name end

	opts.separator 'variant options:'
	opts.on '-V', '--variant [x,y,z]', Array, 'variant list to build, empty for all variants' do |list|
		options[:variants] = list || []
	end

	opts.separator 'info options:'
	opts.on '-h', '--help', 'show this help' do
		puts opts
		exit
	end
	opts.on '-v', '--version', 'show version' do
		puts 'rmk 0.2.0', ''
		exit
	end
}
targets = parser.parse(ARGV)
Dir.chdir options[:prjroot] if options[:prjroot]
options_file = '.rmk/options'
loaded_options = File.exist?(options_file) ? Marshal.load(IO.binread options_file) : {}
changed = false
%i(outroot srcroot link name).each do |key|
	next changed = true if cache_options.include? key
	next cache_options[key] = loaded_options[key] if loaded_options[key]
	changed = true
end
cache_options[:outroot] ||= '_Build'
cache_options[:srcroot] ||= '..'
cache_options[:name] ||= File.basename Dir.pwd
cache_options[:link] ||= File.join ENV['TMP'], cache_options[:name]
if changed
	Dir.mkdir '.rmk' unless Dir.exist? '.rmk'
	IO.binwrite options_file, Marshal.dump(cache_options)
end
dir, link = cache_options[:outroot], cache_options[:link]
if link
	require 'fileutils'
	link = link.gsub(/\$(?:(\$)|{(.*?)})/){$1 || ENV[$2]}.gsub! ?\\, ?\/
	FileUtils.mkpath link unless Dir.exist? link
	if File.symlink? dir
		if File.readlink(dir) != link
			Dir.rmdir dir
			File.symlink link, dir
		end
	elsif Dir.exist?(dir) || File.exist?(dir)
		raise "need symlink '#{dir}' as outroot, but file(or dir) '#{dir}' already exist"
	else
		FileUtils.mkpath File.dirname dir
		File.symlink link, dir
	end
else
	FileUtils.mkpath dir
end
variants = options[:variants]
if variants && variants.size != 1
	if File.exist? 'variants.rmk'
		inifile = IniParse.open 'variants.rmk'
		targets = targets.map{|tgt| %|"#{tgt}"|}.join ' '
		exe = File.join RbConfig::CONFIG['bindir'], RbConfig::CONFIG['ruby_install_name']
		thrs = []
		if variants.empty?
			inifile.each do |vat|
				thrs << Thread.new {system %|"#{exe}" "#{__FILE__}" -V #{vat.key} #{targets}|}
			end
		else
			variants.each do |name|
				thrs << Thread.new {system %|"#{exe}" "#{__FILE__}" -V #{name} #{targets}|} if inifile.has_section? name
			end
		end
		thrs.each{|thr| thr.join}
		exit
	elsif variants.empty?
		raise "no found 'variants.rmk' file for build all variants"
	else
		targets = targets.map{|tgt| %|"#{tgt}"|}.join ' '
		exe = File.join RbConfig::CONFIG['bindir'], RbConfig::CONFIG['ruby_install_name']
		thrs = []
		variants.each {|name| thrs << Thread.new {system %|"#{exe}" "#{__FILE__}" -V #{name} #{targets}|}}
		thrs.each{|thr| thr.join}
		exit
	end
end
if variants
	variants = variants[0]
	src = cache_options[:srcroot].match?(/^[a-z]:\//i) ? cache_options[:srcroot] : File.join('..', cache_options[:srcroot])
	rmk = Rmk.new srcroot:src, outroot:File.join(cache_options[:outroot], variants)
else
	rmk = Rmk.new srcroot:cache_options[:srcroot], outroot:cache_options[:outroot]
end
rmk.parse
rmk.build *targets
